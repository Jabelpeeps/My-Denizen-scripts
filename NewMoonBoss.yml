# Boss Fight - Multistage and Highly Configurable
#
# Currently updated to run with:-
# Citizens 2 (build #1179)
# Denizen-dev 0.9.6 (build #130)
# Sentry 1.8.2 (build #16)
#
# To assign to an NPC, literally type:
# /npc assign --set "NewMoonBoss"
#
# DISCLAIMER:
# ===========
# This is an advanced script. You should test this script before you use it on your LIVE server. Some of the item drops ignore
# ZONE PROTECTION. So if you play on a strict server you will want to disable those items by removing them from the "NewMoonBoss
# Determine Loot" script.
#
# DESCRIPTION:
# ============
#
# This is a four stage boss fight with a bunch of simple configuration options that will allow you to create a unique boss fight.
# You can decide how many stages you want to enable, how difficult the boss should be (health, armor, strength), whether it should
# spawn minions and if so, how many, how difficult etc. The boss has several different 'special attacks' that can be used directly
# on players or inside a "cuboid", which you have to specify in the constant values at the top of the script.
#
# The boss can heal or reset itself if no one is in range.
#
# When the boss is killed, it can drop random loot (defined in item scripts that are located in the separate 
# Bossfight_itmes_and_world_scripts.yml) directly into players inventory, on the floor around the boss or into secure chests for
# each of the boss fighters.
#
# At the end of the fight, it will show a text scoreboard that shows total damage, hit count, minion kills etc for each player.
#
# FEATURES:
# =========
#  * Boss and/or Minions (quantity, health, armour, strength)
#  * Special Attacks (arrow spells, lightning storm, arrows dropping from ceiling)
#  * Boss heal/reset itself if inactive
#  * Unique item drops, using item scripts and world events
#  * Text scoreboard showing battle summary stats
#  * Shows health bar when you right click boss or minion.
#
# NOTE: 
# ====
# If you want to use this on more than one NPC you simply need to do
# a FIND on the word 'NewMoonBoss' and REPLACE it with your NPC name. Then
# make another copy of the script and do another FIND/REPLACE for every
# boss NPC that will use this.
#
# CREDITS:
# ========
# Many thanks to mythanical for the original version of this script, and to the Denizen team for the amazing plugin, and their
# support on #Denizen-dev
# 
# Mythanical gave the following credits:-
# Thanks to aufdemrand, davidcernat and mcmonkey for fixing/adding things in
# Denizen. Thanks to Matterom and blankiito for example scripts on the work 
# they've done on custom items and effects.
#
#
# @author mythanical
# @updated by Jabelpeeps
# @server this script is running on:- Remypas.com (from lobby, go to Jewelcraft world.)
# @irc EsperNet IRC Network #denizen-dev

#=======================================================================================================
"NewMoonBoss":
  type: assignment
  debug: true
   
  default constants:
  # Boss Specific Constants
    # --------------------------------------------------------------------------------------------------------
    # NOTE: 'Player' entity type NPC's are fully supported by Sentry, but other types may give you some
    #       interesting, unexpected or undesired results. Especially when you try and equip them with a
    #       weapon.
    #
    # The following NPC types are available as part of Citizens (http://wiki.citizensnpcs.com/Types):
    #
    # blaze, bat, cave_spider, chicken, creeper, cow, enderman (goes crazy in rain), 
    # ender_dragon (do not recommend), ghast (do not recommend), giant (massive zombie!), iron_golem, 
    # magma_cube (careful! damages nearby players), mushroom_cow, ocelot, pig, pig_zombie, 
    # player (skin name is configurable), sheep, silverfish, squid (can't walk on land...duh),
    # snowman, wolf, skeleton, slime, spider, witch, witherboss (does not move), villager, 
    # zombie (burns in sunlight, but invulnerable)
    # --------------------------------------------------------------------------------------------------------

    World Name: frozen_spring
    Boss Entity Type: player
    
    # Only valid if 'player' entity type is selected. This is the skin of our server owner, any valid MC registered skin should work.
    Boss Skin: RemyPas      
    
    # adult                 (Normal NPC type)
    # baby                  (Cause the Boss to be a baby. Note: Not all entity types have a baby version)
    Boss Age: adult
    
    # The 'baby' type is no longer supported for zombies, so leave the option above set to adult, and change the option below to
    # "-b" for baby zombies, or "-v" for zombie villagers, leave as "none" for standard zombies (or if mob type is not zombie).
    Boss Zombiemod: "none"

    # The following Sentry weapons are fully supported by 'player' type entity (http://wiki.citizensnpcs.com/Sentry):
    # bow                   (Archer - Range is 50 meters on flat ground.)
    # redstone_torch_on     (Pyromancer I - Shoot small, non-incendiary fireballs)
    # torch                 (Pyromancer II -  Shoot fireballs that set the land on fire)
    # blaze_rod             (Pyromancer III - Shoot large, explosive fireballs that set the land on fire)
    # snow_ball             (Ice Magi - Throw snowballs which slow enemies on contact. Range is about 25 blocks on flat ground)
    # egg                   (Bombardiers - explode?  Eggs have a range of about 25 blocks on flat ground)
    # potion                (Witch Doctor - Will throw a splash version of whatever potion type it is equipped with)
    # paper                 (Stormcaller I - Strike single targets with bolts of electricity)
    # book                  (Stormcaller II - Smite multiple foes. This lightning's damage is atmospheric and therefore is not affected by the Sentry's strength)
    # book_and_quill        (Stormcaller III - Bolts instantly kill any living thing they touch regardless of health, armour, or play mode)
    # ender_pearl           (Warlock I - Fling targets high into the air)
    # skull_item            (Warlock II - Mid-range warlock shoots black explosive wither skulls at the enemy)
    # none                  (Brawler - Swords, axes, picks, shovels, rocks, bricks, or even fish, the brawlers take the fight to the enemy, hand to hand)
    Boss Weapon: DIAMOND_SPADE
  
    # The sentry values for the boss, you can check out what these mean at:
    # http://wiki.citizensnpcs.co/Sentry
    Boss Health: 500
    Boss Strength: 1
    Boss Armor: 2
    Boss Agro Range: 40       # sentry default is 10, but I am running the bossfight in a fairly large cavern

    # Awareness range will still trigger special attacks.
    Boss Awareness Range: 50
    Boss Movement Speed: 1
    Boss Attack Rate: 2    # sentry default is 2 (higher number is longer interval between attacks)

    # If all players have left the boss proximity, this enables the boss to heal itself slowly.
    Boss Self Healing: "Yes"

    # Set the location where your boss will respawn
    Boss Spawn Location: "259,108,449,frozen_spring"

    # Set to -1 if you never want the boss to respawn and be permanently destroyed on death.
    Boss Respawn Delay: 600

    # On default, boss fight will reset after 120s of inactivity. Set to 0 if you don't ever want it to reset
    # and allow players to come back later to finish it.
    Boss Reset Timer: 180

    # The item scripts for the loot is located at the bottom. It will give each player, that hit the boss or a minion
    # at least once, a random item.
    Drop Loot on Death: "Yes"

    # The specifies how many randomly selected loot items per player
    Loot Quantity: 1

    # This specifies how the loot should be distributed.
    # player                (Put the item into the players inventory)
    # boss                  (Drop the loot on the ground around the boss)
    # chest                 (Spawn a chest with all the loot inside it where the boss died)
    # playerchest           (Create a chest next to each player that only they can access)
    Loot Distribution: playerchest
    
    # To prevent any loot chests from staying forever, give them any value other than 0
    # and they will expire..dropping all the loot on the floor.
    Loot Chest Expiry: 300

    # Enable scoreboard (on right side of screen) to show either Minion Kills or Boss Health Damage by each player
    # during the fight. This gets removed when the boss is killed.
    # bosshealth            (Show running damage dealt to boss by each player)
    # minionkills           (Show a count for number of minions killed by players)
    # minionhealth          (Show the running damage dealt to minions by each player)
    # none                  (No running battle scoreboard)
    Scoreboard: bosshealth

    # The cuboid is the square area (a room) where most of the fighting will take place. This area can be used in the options below
    # to allow mobs to be spawned in it or to have some of the boss special fighting skills to take place in. 
    Cuboid Spawn Area Poss 1: "219,102,403,frozen_spring"
    Cuboid Spawn Area Poss 2: "304,112,477,frozen_spring"

    # What will trigger the start of the boss fight? 
    # proximity             (Activate if a player walks into the proximity specified in the "Boss Awareness Range" constant value above)
    # damage                (Activate boss fight when damaged by a player)
    Bossfight Activator: proximity 

    # Currently the script supports 4 battle stages, as currently written. A stage is reached/unlocked when the boss is down to a specified health percentage.
    # You decide the boss health percentage, minion names, the quantity to spawn, NPC types and how/where they spawn.
    # If you want less stages, simply remove them from the list. If you don't want any, type in "none". Make sure to type it as "One|Two|Three|Four".
    # If you only want the first two stages, type it as: One|Two  If you want more stages, you will need to modify several sections of the script to allow this.

    Enabled Boss Stages: One|Two|Three|Four
    
    # The sections below detail the separate values for each of the 4 stages of the boss fight. You should modify these to make each boss fight unique.
  
  # Boss Fight - Stage One
    Stage One Boss Health Percentage: 100

    # none                  (No effect around NPC)
    # flame                 (Create a fiery effect around the boss)
    # heart                 (Surrounds the boss with love hearts - kill you with love??)
    # smoke                 (Create a smokey 'pop' effect around the boss)
    # ender                 (Create the Enderman particles around NPC)
    # potbreak              (Not very good, also makes the pot break sound)
    # explosion             (Creeper explosion effect, causes no damage)
    Stage One Boss Aura: smoke

    # "Poison Arrow"        (Shoot a poisonous arrow towards a randomly chosen player. Only casts when the player is hit)
    # "Wither Arrow"        (Cast wither...)
    # "Weakness Arrow"      (Cast weakness...)
    # "Slowness Arrow"      (Cast slowness...)
    # "Rain Arrows"         (Rain arrows from the sky - note: you need provide values for the "Cuboid Spawn Area Poss x" above for this to work)
    # "Lightning Bolt"      (Hit a single random player with a lightning bolt - this never misses)
    # "Lightning Storm"     (Several damaging lightning bolts - note: you to need provide values for the "Cuboid Spawn Area Poss x" above for this to work)
    # "TNT"                 (Boss tosses a block of primed tnt at a random player)
    # "TNT Drop"            (Drop blocks of TNT in random locations in the cuboid - Minecraft/Bukkit bug prevents this from working)
    # "Throw"               (This will cause players to be thrown from their current position to a random location inside the cuboid)
    # "Firestarter"         (Ignite random blocks in the cuboid)
    # none                  (No special attack)
    Stage One Special Attack: "Slowness Arrow"
    
    # This number is only relevant to the following attacks:- "Rain Arrows", "Lightning Storm", "TNT Drop", "Throw", "Firestarter" and configures the number
    # of the attack to be run inside the cuboid defined above.  (The other attacks target a random player, and this option will be ignored.)
    Stage One Special Attack Quantity: 0

    # Run the special attack on a loop, once every 20 seconds.
    Stage One Special Attack Delay: 20s

    # available minion options are in most cases identical to the boss options, therefore see explanations in the boss options section for details.
    Stage One Spawn Minions: "Yes"
    Minion One Type: cave_spider
    Minion One Skin: none
    Minion One Age: adult                  
    Minion One Zombiemod: none            
    Minion One Name: Crawlie
    Minion One Weapon: none
    Minion One Health: 10
    Minion One Quantity: 30
    Minion One Strength: 1
    Minion One Armor: 1
    Minion One Speed: 1.5

    # lightning             (lightning bolt with sound)
    # explode               (harmless explosion effect with sound)
    # none                  (no effect)
    Minion One Spawn Effect: lightning

    # player: spawn around random player
    # boss: spawn around boss
    # cuboid: spawn anywhere inside the cuboid values you specified above
    Minion One Spawn Location: cuboid
    
  # Boss Fight - Stage Two
    Stage Two Boss Health Percentage: 75
    Stage Two Boss Aura: ender
    Stage Two Special Attack: "Wither Arrow"
    Stage Two Special Attack Quantity: 0
    Stage Two Special Attack Delay: 30s
    Stage Two Spawn Minions: "Yes"
    Minion Two Type: zombie
    Minion Two Skin: none
    # the next two entries are configured correctly for baby zombies, see notes in Boss config section, for details.
    Minion Two Age: adult
    Minion Two Zombiemod: "-b"
    Minion Two Name: RemyBaby
    Minion Two Weapon: none
    Minion Two Health: 30
    Minion Two Quantity: 30
    Minion Two Strength: 2
    Minion Two Armor: 3
    Minion Two Speed: 2
    Minion Two Spawn Effect: explode
    Minion Two Spawn Location: boss
    
  # Boss Fight - Stage Three
    Stage Three Boss Health Percentage: 50
    Stage Three Boss Aura: flame
    Stage Three Special Attack: "TNT Drop"
    Stage Three Special Attack Quantity: 40
    Stage Three Special Attack Delay: 20s
    Stage Three Spawn Minions: "Yes"
    Minion Three Type: blaze
    Minion Three Skin: none
    Minion Three Age: adult
    Minion Three Zombiemod: none
    Minion Three Name: FireElement
    Minion Three Weapon: none
    Minion Three Health: 30
    Minion Three Quantity: 15
    Minion Three Strength: 2
    Minion Three Armor: 6
    Minion Three Speed: 1
    Minion Three Spawn Effect: explode
    Minion Three Spawn Location: boss

  # Boss Fight - Stage Four
    Stage Four Boss Health Percentage: 35
    Stage Four Boss Aura: flame
    Stage Four Special Attack: Firestarter
    Stage Four Special Attack Quantity: 25
    Stage Four Special Attack Delay: 20s
    Stage Four Spawn Minions: "Yes"
    Minion Four Type: iron_golem
    Minion Four Skin: none
    Minion Four Age: adult
    Minion Four Zombiemod: none
    Minion Four Name: Terminator
    Minion Four Weapon: none
    Minion Four Health: 50
    Minion Four Quantity: 10
    Minion Four Strength: 3
    Minion Four Armor: 8
    Minion Four Speed: 1.2
    Minion Four Spawn Effect: lightning
    Minion Four Spawn Location: cuboid
    
 #========================actions===============================================================================
  # Congratulations, if you have reached this point, you have configured all the options you need.
  # 
  # ***WARNING*** Only edit the script past this point if you know what you're doing!! ***WARNING***
  #=========================================================================================================
  
  actions:
 #--------------------------on-assignment--------------------------------------------------------
    on assignment:
    # Due to a 'feature' in citizens, that triggers the spawn and despawn actions several times during the processing of this 
    # assignment action, I have needed to use a flag to stop this script, and the spawn+despawn scripts from running 
    # simultaneously, it also stops multiple copies of the same action script running at the same time.
    - if <npc.has_flag[ActionsFinished]> flag npc ActionsFinished:!   
    
    # For this script, the click trigger is only used to return the boss's health.
    - trigger name:click state:true
    # Proximity set to the radius you specified in the "Boss Awareness Range" constant above.
    - trigger name:proximity state:true "radius:<npc.constant[Boss Awareness Range]>"
    # Damage trigger does a whole bunch of stuff which I'll explain in that section.
    - trigger name:damage state:true

    # Create a NPC flag called "cuboid" that stores the cuboid values in a simple shorter name which makes it easy for reuse.
    - define AreaPoss1 '<npc.constant[Cuboid Spawn Area Poss 1]>'
    - define AreaPoss2 '<npc.constant[Cuboid Spawn Area Poss 2]>'
    - flag npc 'cuboid:<el@val[%AreaPoss1%|%AreaPoss2%].as_cuboid>'

    # The following commands sets up the Boss using the values specified in the constants above.
    - teleport <npc> 'location:<npc.constant[Boss Spawn Location]>'
    - execute as_server "npc sel <npc.id>" silent
    - execute as_server "npc type <npc.constant[Boss Entity Type]>" silent
    - if '<npc.constant[Boss Age]>' == baby execute as_server "npc age baby -l" silent
    - if '<npc.constant[Boss Entity Type]>' contains player {
      - execute as_server "npc skin <npc.constant[Boss Skin]>" silent
      - execute as_server "npc playerlist" silent }
      else if '<npc.constant[Boss Entity Type]>' == zombie && '<npc.constant[Boss Zombiemod]>' != none execute as_server "npc zombiemod <npc.constant[Boss Zombiemod]>" silent
    - anchor id:BossSpawn add 'location:<npc.constant[Boss Spawn Location]>'
    - anchor id:BossSpawn walknear r:10
    - execute as_server "npc speed <npc.constant[Boss Movement Speed]>" silent
    # - execute as_server "npc lookclose"                # commented out as we have this on by default on our server
    - lookclose <npc> state:true range:10 
    - trait state:true sentry
    - execute as_server "sentry health <npc.constant[Boss Health]>" silent
    - execute as_server "sentry respawn <npc.constant[Boss Respawn Delay]>" silent
    - execute as_server "sentry attackrate <npc.constant[Boss Attack Rate]>" silent
    - execute as_server "sentry speed <npc.constant[Boss Movement Speed]>" silent
    - execute as_server "sentry strength <npc.constant[Boss Strength]>" silent
    - execute as_server "sentry armor <npc.constant[Boss Armor]>" silent
    - execute as_server "sentry range <npc.constant[Boss Agro Range]>" silent
    - if "<npc.constant[Boss Weapon]>" != none execute as_server "sentry equip <npc.constant[Boss Weapon]>" silent

    # Put the boss stages into a flag - this will be used throughout to check which boss stages should be activated.
    - flag npc "Enabled Boss Stages:<npc.constant[Enabled Boss Stages]>"

    # This is used in world events further down to prevent self/minion harm.
    - if <global.flag[ListOfBosses].as_list||li@> !contain <npc> flag global ListOfBosses:->:<npc>
    
    # This is used by the minions to prevent teleporting to players when the player exits
    # their awareness range. (Temporary until Sentry is fixed) <- I should check out whether this is fixed.
    - flag npc "Minion Awareness Range:<npc.constant[Boss Awareness Range]>"
    # see note at top of this script for an explanation of what this last flag does.
    - flag npc ActionsFinished    
 #--------------------------on-spawn-------------------------------------------------------------
    on spawn:
    # see note at top of the 'on assignment' script for an explanation of what this flag does.
    - if <npc.has_flag[ActionsFinished]> flag npc ActionsFinished:! else queue clear
    # these commands are specific to our world, given it's fixed cuboid location. It puts out any fires remaining behind from the previous fight.
    - define cuboid <el@val[l@210,102,398,frozen_spring|l@311,124,496,frozen_spring].as_cuboid>
    - modifyblock <%cuboid%.get_blocks[fire]> air
    
    # Teleport boss back to starting point.
    - teleport <npc> 'location:<npc.constant[Boss Spawn Location]>'

    # Every time the boss spawns after it's been killed, it'll run through the following process to do some 'clean-up' from the previous battle.
    #
    # First it runs through a global "minion" list and check to see whether they are spawned and if they have a "creator". It then removes 
    # them from the global list and executes the "remove" command to permanently get rid of them.
    #
    # Clear the Sentry target list, so it doesn't attack players unprovoked.
    #
    # Remove the "R.I.P" sign it placed when and where it died.
    #
    - if <npc.has_flag[BossDied]> {
      - flag npc BossDied:!
      - foreach <global.flag[AllMinions].as_list> {
        - if !<util.npc_is_valid[%value%]> flag global AllMinions:<-:<el@val[%value%].escaped>
          else if <%value%.flag[MinionCreator]||null> == <npc> {
          - flag global AllMinions:<-:%value%
          - remove %value% }
        }
      - execute as_server "npc sel <npc.id>" silent
      - execute as_server "sentry target clear" silent
      - define deathlocation <npc.flag[DeathLocation].as_location||null>
      - if <%deathlocation%.block.sign_contents||null> contains <npc.name> modifyblock %deathlocation% air
    } 
    # the npc now adds itself back to the list of bosses (if needed)
    - if <global.flag[ListOfBosses]||li@> !contain <npc> flag global ListOfBosses:->:<npc>
    # see note at top of the 'on assignment' script for an explanation of what this flag does.
    - flag npc ActionsFinished
    
    # Now the clean up is finished it is time to set up the Minecraft scoreboard.
    #
    # First it checks to see if its meant to create a Scoreboard, if so, it'll flag the NPC with what the scoreboard should show:
    #   * bosshealth
    #   * minionkills
    #   * miniondamage
    # It uses the "substring" to put a limit in place for the length of the boss's name because if the name is too long, the scoreboard will fail to create.  
    #
    - ^if <npc.constant[Scoreboard]> != none && !<npc.has_flag[Scoreboard]> {
      - ^flag <npc> Scoreboard:<npc.constant[Scoreboard]>
      - ^if <npc.flag[Scoreboard]> == "bosshealth" {
        - execute as_server "scoreboard objectives add <npc.name.substring[1,9]>.Damage dummy" silent
        - execute as_server "scoreboard objectives setDisplay sidebar <npc.name.substring[1,9]>.Damage" silent
        - queue clear }
      - ^if <npc.flag[Scoreboard]> == "minionkills" {
        - execute as_server "scoreboard objectives add <npc.name.substring[1,5]>.MinionKills dummy" silent
        - execute as_server "scoreboard objectives setDisplay sidebar <npc.name.substring[1,5]>.MinionKills" silent
        - queue clear }
      - execute as_server "scoreboard objectives add <npc.name.substring[1,6]>.MinionDmg dummy" silent
      - execute as_server "scoreboard objectives setDisplay sidebar <npc.name.substring[1,6]>.MinionDmg" silent 
    }    
 #--------------------------on-death------------------------------------------------------------
    on death:
    # When the boss dies, there is a bunch of clean-up that needs to happen. 
    
    # This flag is used to prevent certain "on spawn" commands from running unless the boss actually died. 
    - flag npc BossDied
    # This prevents the Boss npc.id being immediately removed so that the tags in this script that refer to him remain valid.
    - determine passively cancelled
    # This line will (hopefully) terminate the special attack queue immediately on the death of the Boss
    - define SpecialAttackQueue 'Boss<npc.id>SpecialAttack'
    - if <queue.exists[%SpecialAttackQueue%]> queue 'queue:%SpecialAttackQueue%' clear
    
    # Here are some 'foreach' loops to remove all the minions that were created during the various stages. 
    # Each minion was added to the boss flag list and now it simply iterates through removing each minion 
    # by substituting %value% with their NPC ID, e.g.  n@123    
    - foreach '<npc.flag[Enabled Boss Stages].as_list>' {
      # the %value% on the next line is the Boss fight stage, from the foreach on the line above.
      - foreach '<npc.flag[Stage%value%Minions].as_list>' {  
        # the %value% on the next lines is the NPC ID.
        - flag global AllMinions:<-:%value%
        - if <npc> != %value% remove %value% }                
    }
    # It then clears the minion list for each battle stage. NB adding this to the previous foreach loop produced unwanted behaviour.
    - foreach '<npc.flag[Enabled Boss Stages].as_list>' {
      - flag <npc> 'Stage%value%Minions:!' }
     
    # Remove/comment out the next 2 lines if you don't want a sign marking where the Boss Died.
    # What it does is flag where the boss died and post a sign with the boss's name, followed by "was defeated here". 
    # The "|" in the sign command means go onto the next line of the sign.
    - flag npc DeathLocation:<npc.location.simple>
    - sign <npc.flag[DeathLocation]> "<npc.name>|was defeated|here."

    # The following section builds the text scoreboard that is displayed in the Minecraft chat when the boss has been killed.
    #
    # The IF checks to see if anybody hit the boss at any point (using the "BossHitList" flag).
    # You'll see further down that this list is populated by the damage trigger from when the boss is hit by a player.
    #
    # It then announces to the server the result of the battle. It uses a foreach loop to cycle through
    # all players that hit the boss (even those that didn't penetrate its armour) and shows for each player
    # how much damage, their overall damage percentage and the number of times they hit the boss.
    #
    # If the player also damaged and killed minions, it will show another line with minion total damage, hit count and number of minions killed.
    #
    # This is all recorded into flags during the damage trigger and on death action for the boss and minions.
    #
    # At the bottom it shows a list of all players that got into the "Boss Awareness Range" but never damaged/hit the boss or minions, e.g SPECTATORS.
    #
    # During the foreach loop, it also clears all the player flags to ready them for their next battle.

    - if <npc.has_flag[BossHitList]> {
      - announce "<green>------------------------------------------"
      - announce "<red>BOSS EVENT<&co> <white><npc.name><red> has been killed by <yellow><npc.flag[BossHitList].formatted>"
      - announce "<green>------------------------------------------"
      - announce "<green><underline>Battle Stats<&co>"
      - announce ""
      - announce "<red><npc.name> Total Health<&co> <npc.health.max.as_int>"
      - define maxHealth <npc.health.max>
      - define BossDamage '<npc.name>_TotalDamage'
      - foreach <npc.flag[BossHitList].as_list> {
        - define PlayerBossDamage <%value%.flag[%BossDamage%]||0>
        - define DamagePercent <el@val[<m:%PlayerBossDamage%/%maxHealth%*100>].as_int>
        - announce "<yellow><%value%.name>"
        - define HitCount '<npc.name>_HitCount'
        - announce "<aqua>Boss Damage <gold>%PlayerBossDamage% (%DamagePercent%<&pc>) <aqua>- Hits <gold><%value%.flag[%HitCount%].as_int>"
        - define MinsDamage '<npc.name>_MinsDamage'
        - if <%value%.flag[%MinsDamage%]||null> != null {
          - define MinsKilled <npc.name>_MinsKilled
          - define MinsHit <npc.name>_MinsHit
          - announce "<aqua>Combined Minion Damage <gold><%value%.flag[%MinsDamage%].as_int||0> <aqua>- Hits <gold><%value%.flag[%MinsHit%].as_int||0> <aqua>- Minions Killed <gold><%value%.flag[%MinsKilled%].as_int||0>" }
        - flag player:%value% <npc.name>_TotalDamage:!
        - flag player:%value% <npc.name>_HitCount:!
        - flag player:%value% <npc.name>_MinsKilled:!
        - flag player:%value% <npc.name>_MinsHit:!
        - flag player:%value% <npc.name>_MinsDamage:! }
      - announce "<green>------------------------------------------" }
    - if <npc.has_flag[BossSpectatorList]> {
      - foreach <npc.flag[BossSpectatorList].as_list> {
        - if <npc.flag[BossHitList].as_list> contains %value% flag npc BossSpectatorList:<-:%value% }
      - if <npc.flag[BossSpectatorList].size> >= 1 announce "Spectators <npc.flag[BossSpectatorList].formatted>" }
   
    # Now we check to see if the "Drop Loot on Death" is set to "Yes", and if so run the task called "NewMoonBoss Drop the Loot" instantly.
    - if '<npc.constant[Drop Loot on Death]>' == "Yes" run "NewMoonBoss Drop the Loot" instantly
      
    # Remove any visual effects applied at fight stages and clear sentry targets.
    - execute as_server "npc sel <npc.id>" silent
    - execute as_server "npc effect --play none" silent
    - execute as_server "sentry target clear" silent

    # If the scoreboard was enabled, this will remove it so it doesn't stay behind on player's screens.
    - if <npc.has_flag[Scoreboard]> {
      - if <npc.flag[Scoreboard]> == "bosshealth" execute as_server "scoreboard objectives remove <npc.name.substring[1,9]>.Damage" silent
        else if <npc.flag[Scoreboard]> == "minionkills" execute as_server "scoreboard objectives remove <npc.name.substring[1,5]>.MinionKills" silent
        else if <npc.flag[Scoreboard]> == "minionhealth" execute as_server "scoreboard objectives remove <npc.name.substring[1,6]>.MinionDmg" silent }

    # Clear all the flags used during the fight to set boss up for the next fight.
    - flag npc BossHitList:!
    - flag npc BossSpectatorList:!
    - flag npc BossStage:!
    - flag npc BossPlayerList:!
    # - flag npc BadLoopProtect:!    # I'm not sure this one is being used.
    - flag npc ActiveSpecialAttackStage:!
    - flag global ListOfBosses:<-:<npc>
    - flag npc MinionSpawnedStage:!
    - flag npc Scoreboard:!
    - flag npc AllMyMinions:!
    - flag npc BossResetTimer:!
    - flag npc HealActive:!
    # despawn the boss, giving the appearance of him dying. 
    - despawn 

 #--------------------------on-despawn----------------------------------------------------------
    on despawn:
    # first a check to stop this script running if the boss is already dead.
    - if <npc.has_flag[BossDied]||null> queue clear
    # see note at top of the 'on assignment' script for an explanation of what this flag does.
    - if <npc.has_flag[ActionsFinished]> flag npc ActionsFinished:! else queue clear
    
    # otherwise, this script contains a sub-set of the 'on death' script commands.
    - define SpecialAttackQueue 'Boss<npc.id>SpecialAttack'
    - if <queue.exists[%SpecialAttackQueue%]> queue 'queue:%SpecialAttackQueue%' clear
    - define BossHealQueue <npc.name>_BossHeal
    - if <queue.exists[%BossHealQueue%]> queue 'queue:%BossHealQueue%' clear
    
    - foreach '<npc.flag[Enabled Boss Stages].as_list>' {
      - if <npc.has_flag[Stage%value%Minions]> {
        - foreach <npc.flag[Stage%value%Minions].as_list> {
          - if <npc> != %value% remove %value% 
        }
      }
    }
    - foreach '<npc.flag[Enabled Boss Stages].as_list>' {
      - flag <npc> 'Stage%value%Minions:!' }
      
    - if <npc.flag[BossHitList].size> >= 1 {
      - foreach <npc.flag[BossHitList].as_list> {
        - flag player:%value% <npc.name>_TotalDamage:!
        - flag player:%value% <npc.name>_HitCount:!
        - flag player:%value% <npc.name>_MinsKilled:!
        - flag player:%value% <npc.name>_MinsHit:!
        - flag player:%value% <npc.name>_MinsDamage:! 
      }
    }
    - execute as_server "npc sel <npc.id>" silent
    - execute as_server "npc effect --play none" silent
    - execute as_server "sentry target clear" silent
    - if <npc.has_flag[Scoreboard]> {
      - if <npc.flag[Scoreboard]> == bosshealth execute as_server "scoreboard objectives remove <npc.name.substring[1,9]>.Damage" silent
        else if <npc.flag[Scoreboard]> == minionkills execute as_server "scoreboard objectives remove <npc.name.substring[1,5]>.MinionKills" silent
        else if <npc.flag[Scoreboard]> == minionhealth execute as_server "scoreboard objectives remove <npc.name.substring[1,6]>.MinionDmg" silent
    }
    - flag <npc> BossHitList:!
    - flag <npc> BossSpectatorList:!
    - flag <npc> BossStage:!
    - flag <npc> BossPlayerList:!
    # - flag <npc> BadLoopProtect:!  not sure that this flag is being used.
    - flag <npc> ActiveSpecialAttackStage:!
    - flag <npc> MinionSpawnedStage:!
    - flag <npc> Scoreboard:!
    - flag <npc> AllMyMinions:!
    - flag <npc> BossResetTimer:!
    - flag <npc> HealActive:!
    
    # see note at top of the 'on assignment' script for an explanation of what this flag does.
    - flag npc ActionsFinished    
 #--------------------------on-damaged---(WIP)------------------------------------------------------
  #on damaged:
  # originally handled in a damage trigger, and requiring the use of several flags and maths tags, I am trying out managing 
  # damage on the npc in the actions section, so that I can use the <context.damage> and <context.damager> tags. 
  
  
  
 #------------------------interact---------------------------------------------------------- 
  interact scripts:
  - 10 NewMoonBoss Script
  
#======================================================================================================================
"NewMoonBoss Script":
  type: interact
  debug: true
  steps:
    1:
      click trigger:
        script:
        # Right clicking the boss will run the "Health Status Bar" task that'll construct a
        # text based health bar that will show in the Minecraft chat window.
        - run "Health Status Bar"

      proximity trigger:
        entry:
          script:
          # When a player enters the proximity set in the "Boss Awareness Range" constant value, it'll check to see
          # if they are already on the list and if not it will add them to the "BossPlayerList" flag. This is used for
          # targetted narrate messages throughout the fight.
          - if <npc.flag[BossPlayerList].as_list||li@> !contains <player> && <player.name> != <npc.name> flag npc BossPlayerList:->:<player>
          
          # Add players to the spectator list, which shows up in the battle stats after the boss fight.
          - if <npc.flag[BossSpectatorList].as_list||li@> !contains <player> && <player.name> != <npc.name> flag npc BossSpectatorList:->:<player>
          
          # If proximity was set as the "NewMoonBoss Fight Activator" in the constant values at the top, this will
          # start the fight if there isn't already an active fight stage.
          - if '<npc.constant[Bossfight Activator]>' == "proximity" && !<npc.has_flag[BossStage]> {
            - flag npc BossStage:One
            - run "NewMoonBoss Fight" }
            else if <npc.has_flag[BossStage]> run "NewMoonBoss Fight"
            
          # this line ends the queue for the self heal task, if it has been activated.
          - define BossHealQueue <npc.name>_BossHeal
          - if <queue.exists[%BossHealQueue%]> queue 'queue:%BossHealQueue%' clear

          # This resets the timer when a player enters proximity so the boss does NOT get reset after the period
          # of inactivity specified in the "NewMoonBoss Reset Timer" constant value up top.
          - flag npc BossResetTimer:!

        exit:
          script:
          - define BossRange '<npc.constant[Boss Awareness Range]>'
          - if <npc.navigator.target_entity||none> == <player> && <npc.location.find.players.within[%BossRange%].size||0> >= 1 {
            - attack <npc> 'target:<npc.location.find.players.within[%BossRange%].get[1]>' }
            else attack stop

          # The wait 10 allows for a buffer where players are on the edge of the proximity moving in and out.
          - wait 10s

          # If the fight has been activated (i.e. it hasn't got a null boss stage), and there are still no players in proximity
          # and self healing has been enabled in the constants, run the "NewMoonBoss Self Heal" task.
          - define NearbyPlayersSize <npc.location.find.players.within[%BossRange%].size||0>
          - if %NearbyPlayersSize% < 1 && <npc.has_flag[BossStage]> && '<npc.constant[Boss Self Healing]>' == "Yes" {
            - run "NewMoonBoss Self Heal" id:<npc.name>_BossHeal }

          # Same as above, except this kicks off the overall "NewMoonBoss Reset" task with a delay timer (set in 
          # "NewMoonBoss Reset Timer" constant above).
          - if %NearbyPlayersSize% < 1 && <npc.has_flag[BossStage]> && '<npc.constant[Boss Reset Timer]>' >= 1 && !<npc.has_flag[BossResetTimer]> {
            - flag <npc> BossResetTimer
            - run "NewMoonBoss Reset" id:<npc.name>_ResetTimer 'delay:<npc.constant[Boss Reset Timer]>'
          }
      damage trigger:
        script:
        # Every time the boss is hit (whether they are actually damaged or not), it will the commands below.
        #
        # The first IF is to save the current boss health into a defined value called "phealth".
        - ^if <npc.is_spawned> define phealth <npc.health.as_int>

        # This tick is necessary to allow time for the damage value to be applied to the NPC.
        - wait 1t

        # If the player managed to get through the "entry proximity" without being added to the "BossPlayerList"
        # it will do it now.
        - ^if <npc.flag[BossPlayerList].as_list||li@> !contains <player> && <player.name> != <npc.name> flag <npc> BossPlayerList:->:<player>

        # Start counting the number of times the player has hit the boss. Add "+1" every time they trigger this.
        - ^flag player <npc.name>_HitCount:++

        # Add the player into the "BossHitList" if they aren't already.
        - ^if <npc.flag[BossHitList].as_list||li@> !contains <player> && <player.name> != <npc.name> flag <npc> BossHitList:->:<player>

        # The following IF is used to check the boss's current health. If their health is lower than the specified
        # percentage in the "Stage One/Two/Three/Four Boss Health Percentage" constant values, it will activate the
        # next fighting stage.
        # It flags (flag npc BossStage:One etc) the stage it's at because this is used to control the flow of
        # stages and also used during the "Special Attack" loop tasks further down.
        - ^define BossStage <npc.flag[BossStage]||null>
        - ^define BossHealth <npc.health.percentage.as_int||0>
        - ^define EnabledStages '<npc.flag[Enabled Boss Stages].as_list>'
        - ^if %EnabledStages% contains One && %BossStage% contains null && %BossHealth% <= '<npc.constant[Stage One Boss Health Percentage]>' {
            - flag npc BossStage:One
            - run "NewMoonBoss Fight" }
          else if %EnabledStages% contains Two && %BossStage% contains One && %BossHealth% <= '<npc.constant[Stage Two Boss Health Percentage]>' {
            - flag npc BossStage:Two
            - run "NewMoonBoss Fight" }
          else if %EnabledStages% contains Three && %BossStage% contains Two && %BossHealth% <= '<npc.constant[Stage Three Boss Health Percentage]>' {
            - flag npc BossStage:Three
            - run "NewMoonBoss Fight" }
          else if %EnabledStages% contains Four && %BossStage% contains Three && %BossHealth% <= '<npc.constant[Stage Four Boss Health Percentage]>' {
            - flag npc BossStage:Four
            - run "NewMoonBoss Fight" }

        # The new NPC remaining value is then subtracted off the previous damage value. This is then
        # added into a player flag as the total damage value they inflicted. 
        - ^define health <npc.health>
        - ^if <npc.is_spawned> define finaldamage <el@val[<m:%phealth%-%health%>].as_int>
          else define finaldamage %phealth%
        - ^flag player <npc.name>_TotalDamage:+:%finaldamage%

        # Add the damage amount into the Minecraft scoreboard. (Right hand side of players screen).
        - if <npc.flag[Scoreboard]> == bosshealth && %finaldamage% != 0 execute as_server "scoreboard players add <player.name> <npc.name.substring[1,9]>.Damage %finaldamage%" silent

#====================================================================================================================================
"NewMoonBoss Fight":
  type: task
  debug: false
  script:
  # first a check to stop this script running if the boss is already dead.
  - if <npc.has_flag[BossDied]||null> queue clear
  
  # Every time a stage kicks off, this is the script it runs.
  # Initially it announces the boss health percentage to the "BossPlayerList" (so not everyone on the server gets the message, only the participants. 
  # It also runs the "Health Status Bar" script which displays a dynamic text based health bar.
  - ^define BossStage <npc.flag[BossStage]||none>
  - ^define SpecialAttack '<npc.constant[Stage %BossStage% Special Attack]||null>'
  - ^narrate "<red>Boss Stage %BossStage%> - Health <npc.health.percentage.as_int><&pc>" targets:<npc.flag[BossPlayerList].as_list||null>
  - ^run "Health Status Bar"

  # Flags the boss with the current stage special attack, used by the special attack tasks to run (or not if it's not relevant for that stage anymore).
  - ^flag npc "CurrentSpecialAttack:%SpecialAttack%"

  # Each stage can also have a different effect play around/near the boss, this is checked here and applied with the "execute as_server" command.
  # If there is no effect for this stage, it removes it with the "--play none" parameter below.
  - ^if flame|heart|smoke|ender|potbreak|explosion contains "<npc.constant[Stage %BossStage% Boss Aura]>" {
      - execute as_server "npc sel <npc.id>" silent
      - execute as_server "npc effect --play none" silent
      - execute as_server "npc effect --play <npc.constant[Stage %BossStage% Boss Aura]>" silent }
      else {
        - execute as_server "npc sel <npc.id>" silent
        - execute as_server "npc effect --play none" silent }

  # The next section is where the minions are spawned, if enabled, for the relevant boss stage.
  # For the "repeat" command, it runs the number of times based on the number of minions you've set to spawn in the "... Minion Quantity" constant 
  # values  at the top for each stage.
  #
  # It uses a global flag (TempBossId) to store the boss's NPC ID which is then put into a for each of the minions - so it creates a relationship of 
  # sorts between the boss & minions so they can be despawned when the boss dies for example.
  #
  # It checks to see where the minions should spawn based on your set spawn location, 'player', 'cuboid' or 'boss'. Then it uses a great tag 
  # combination "get_spawnable_blocks.random" to pick a random "safe" location for the minion to spawn. This prevents *most* NPC's from spawning 
  # inside walls.
  #
  # Then, once its got the location it runs the "NewMoonBoss Spawn Minion" task instantly. This is explained further down when you get to the task.
  #
  # Once the minion has been created, it'll make it a baby if a) you enabled it  b) if the NPC type supports it. It then applies all the sentry values
  # you've set at each stage in the constants at the top of the script. Lastly, it adds "player" type to it's Sentry target list, picks a random 
  # player from the BossPlayerList and..well.. attacks it.

  - if '<npc.constant[Stage %BossStage% Spawn Minions]>' == "Yes" && <npc.flag[MinionSpawnedStage]||none> != %BossStage% {
    - flag <npc> MinionSpawnedStage:%BossStage%
    - define MinionSpawn '<npc.constant[Minion %BossStage% Spawn Location]>'
    - flag global TempBossId:<npc>
    - if %MinionSpawn% == cuboid define cuboid <npc.flag[cuboid]>
      else if %MinionSpawn% == boss {
        - define location <npc.location.simple>
        - define cuboid <el@val[<l@%location%.add[l@-5,0,-5]>|<l@%location%.add[l@5,1,5]>].as_cuboid> 
      }
    - repeat '<npc.constant[Minion %BossStage% Quantity]>' {
      - if %MinionSpawn% == player {
        - define selplayer <npc.flag[BossPlayerList].as_list.random||null>
        - define location <player[%selplayer%].location.simple>
        - define cuboid <el@val[<l@%location%.add[l@-3,0,-3]>|<l@%location%.add[l@3,1,3]>].as_cuboid> }
      - flag <npc> SpawnLocation:<%cuboid%.get_spawnable_blocks.random>
      - run "NewMoonBoss Spawn Minion" instantly 
    }
  }
  # start minion attacking a random player if not already doing so.
  - if <npc.flag[Stage%BossStage%Minions].size> >= 1 {
    - foreach <npc.flag[Stage%BossStage%Minions].as_list> {
      - if <%value%.navigator.target_entity.type||null> != player attack %value% target:<npc.flag[BossPlayerList].as_list.random||cancel> }
  }
  # The server then select the boss ID again and also adds "player" type as it's target.
  - ^execute as_server "npc sel <npc.id>" silent
  - ^execute as_server "sentry target add entity<&co>player" silent

  # Each stage can have a different special attack. This is where that process kicks off. First it checks
  # what the attack is for the particular stage the boss is on, then flags the NPC with the
  # "ActiveSpecialAttackStage" which is used by the special attack tasks to run or cancel further down.
  - ^if "Poison Arrow|Wither Arrow|Weakness Arrow|Slowness Arrow" contains %SpecialAttack% {
    - flag <npc> ActiveSpecialAttackStage:Arrows
    - run "NewMoonBoss Special Attack - Arrows" }
    else if %SpecialAttack% == "Rain Arrows" {
      - flag <npc> "ActiveSpecialAttackStage:Rain Arrows"
      - run "NewMoonBoss Special Attack - Rain Arrows" }
    else if %SpecialAttack% == "Lightning Bolt" {
      - flag <npc> "ActiveSpecialAttackStage:Lightning Bolt"
      - run "NewMoonBoss Special Attack - Lightning Bolt" }
    else if %SpecialAttack% == "Lightning Storm" {
      - flag <npc> "ActiveSpecialAttackStage:Lightning Storm"
      - run "NewMoonBoss Special Attack - Lightning Storm" }
    else if %SpecialAttack% == "TNT" {
      - flag <npc> "ActiveSpecialAttackStage:TNT"
      - run "NewMoonBoss Special Attack - TNT" }
    else if %SpecialAttack% == "TNT Drop" {
      - flag <npc> "ActiveSpecialAttackStage:TNT Drop"
      - run "NewMoonBoss Special Attack - TNT Drop" }
    else if %SpecialAttack% == "Throw" {
      - flag <npc> "ActiveSpecialAttackStage:Throw"
      - run "NewMoonBoss Special Attack - Throw" }
    else if %SpecialAttack% == "Firestarter" {
      - flag <npc> "ActiveSpecialAttackStage:Firestarter"
      - run "NewMoonBoss Special Attack - Firestarter" }
    else if %SpecialAttack% == none flag <npc> ActiveSpecialAttackStage:!
  
  # If for some reason Sentry is delayed (known issue which I've logged here: https://github.com/jrbudda/Sentry/issues/161) this will
  # make sure if it's got no target to pick the closest player and attack them.
  - define BossRange '<npc.constant[Boss Awareness Range]>'
  - ^if <npc.navigator.target_entity||null> == null attack <npc> 'target:<npc.location.find.players.within[%BossRange%].get[1]||cancel>'

#==========================================================================================================================================
"NewMoonBoss Spawn Minion":
    # NB this script is run by the boss; therefore <npc> tags here refer to boss, not the Minion.
    type: task
    debug: false
    script:
    
    # Here it initially defines the boss stage and then use that to pick:
    # 1) Which effect is used to spawn the minion
    # 2) Give it a name, a type, speed and make it a Sentry.
    
    - define BossID <global.flag[TempBossId]>
    - define BossStage <%BossID%.flag[BossStage]>
    - if "<%BossID%.constant[Minion %BossStage% Spawn Effect]>" == lightning strike no_damage location:<%BossID%.flag[SpawnLocation]>
      else if "<%BossID%.constant[Minion %BossStage% Spawn Effect]>" == explode explode power:1 location:<%BossID%.flag[SpawnLocation]>

    # The most effective way to create an NPC is to fit as MANY of the possible parameters into the "npc create" command
    # as possible. This avoids a scenario where the players can witness the NPC's changing or being teleported to where
    # you intended etc.
    - execute as_server "npc create <%BossID%.constant[Minion %BossStage% Name]> --at <%BossID%.flag[SpawnLocation]> --type <%BossID%.constant[Minion %BossStage% Type]> --speed <%BossID%.constant[Minion %BossStage% Speed]> --trait sentry" silent
    
    - if '<npc.constant[Minion %BossStage% Type]>' == zombie && '<npc.constant[Minion %BossStage% Zombiemod]>' != none {
        - execute as_server "npc zombiemod <npc.constant[Minion %BossStage% Zombiemod]>" silent }
        else {
        - if '<npc.constant[Minion %BossStage% Type]>' contains player execute as_server "npc skin <npc.constant[Minion %BossStage% Skin]>" silent
        - if '<%BossID%.constant[Minion %BossStage% Age]>' == baby execute as_server "npc age baby -l" silent }
    
    # This sets the minions owner to be the boss. It's only use seems to be to quiet the NPC death notification errors that happen with no owner set.
    - execute as_server "npc owner <%BossID%.name>" silent
    
    # setup various sentry options for minions
    - execute as_server "sentry respawn -1" silent
    - if '<%BossID%.constant[Minion %BossStage% Weapon]>' != none execute as_server "sentry equip <%BossID%.constant[Minion %BossStage% Weapon]>" silent
    - execute as_server "sentry health <%BossID%.constant[Minion %BossStage% Health]>" silent
    - execute as_server "sentry strength <%BossID%.constant[Minion %BossStage% Strength]>" silent
    - execute as_server "sentry armor <%BossID%.constant[Minion %BossStage% Armor]>" silent
    - execute as_server "sentry target add entity<&co>player" silent
    # Assign the "NewMoonBoss Minion Basics" script to each minion.
    - execute as_server 'npc assign --set "NewMoonBoss Minion Basics"' silent

#====================================================================================================================
"NewMoonBoss Minion Basics":
  # this script is run by the Minions, on it being assigned to them, by the script above.  Therefore <npc> tags here refer to the Minion.
  type: assignment
  debug: false
  actions:
    on assignment:
    - trigger name:click state:true
    - trigger name:damage state:true
    
    - define BossID <global.flag[TempBossId]>
    - define BossStage <%BossID%.flag[BossStage]>

    # Add this NPC id to a global "AllMinions" list.. this is checked by the boss on spawn
    # to clean up any left behind NPC's if something went wrong or server shutdown midway
    # through a fight.
    - ^flag global AllMinions:->:<npc>

    # Flag the minion with the boss ID. This allows the minion to updates flags on the boss,
    # e.g. the "BossPlayerList" or to add itself to the "AllMyMinions" list which is checked
    # during the "NewMoonBoss Prevent Self Harm" script.
    - ^flag <npc> MinionCreator:%BossID%

    # Minion adds itself into the boss's minion list flags.
    - ^flag %BossID% Stage%BossStage%Minions:->:<npc>
    - ^flag %BossID% AllMyMinions:->:<npc>
    
    # If player exits this proximity range the minion will stop attacking. (Temporary until Sentry is fixed)
    - ^flag npc "Minion Awareness Range:<%BossID%.flag[Minion Awareness Range]>"
    - ^trigger name:proximity state:true "radius:<npc.flag[Minion Awareness Range]>"

#-------------------------------------------------------------------------------------------------------------------
    on death by player:
    - ^determine passively cancelled
    - ^define mincreator <npc.flag[MinionCreator]>
    # When the minion is killed by a player (rather than by other mobs or the environment) it
    # will add 1 to player flag keeping a count of minions killed.
    - ^flag player <%MinionCreator%.name>_MinsKilled:++

    # Remove the minion from the "AllMinions" global flag (used to clean up if minions left
    # behind for whatever reason).
    - ^flag global AllMinions:<-:<npc>
    # Remove the minion from the boss's minion list.
    - ^flag %mincreator% AllMyMinions:<-:<npc>
    # If the scoreboard is set to record minions killed count, add one to the player score.
    - if <%mincreator%.flag[Scoreboard]> == minionkills execute as_server "scoreboard players add <player.name> <%mincreator%.name.substring[1,5]>.MinionKills 1" silent
    - ^remove <npc>
#---------------------------------------------------------------------------------------
  interact scripts:
  - 5 NewMoonBoss Minion Triggers
  
#====================================================================================================================
"NewMoonBoss Minion Triggers":
# NB script run by Minion, so <npc> tags in this script refer to Minions, not the Boss.
  type: interact
  debug: false
  steps:
    1:
      damage trigger:
        script:
        # This damage trigger is very similar to the boss's, so won't explain what happens here.
        - ^define phealth <npc.health>
        - ^define mincreator <npc.flag[MinionCreator]>
        - wait 1t
        - ^if <%mincreator%.flag[BossPlayerList].as_list> !contains <player> && <player.name> != <%mincreator%.name> {
          - flag <%mincreator%> BossPlayerList:->:<player> }
        - ^if <%mincreator%.flag[BossHitList].as_list> !contains <player> && <player.name> != <%mincreator%.name> {
          - flag <%mincreator%> BossHitList:->:<player> }
        - ^if !<npc.is_spawned||false> define finaldamage <el@val[%phealth%].as_int>
          else {
            - define health <npc.health>
            - define finaldamage <el@val[<m:%phealth%-%health%>].as_int> }
        - ^flag player <%mincreator%.name>_MinsDamage:+:%finaldamage%
        - ^flag player <%mincreator%.name>_MinsHit:++
        - ^if <%mincreator%.flag[Scoreboard]> == minionhealth && %finaldamage% != 0 { 
          - execute as_server "scoreboard players add <player.name> <%mincreator%.name.substring[1,6]>.MinionDmg %finaldamage%" silent }

      click trigger:
        script:
        - run "Health Status Bar"

      proximity trigger:
        exit:
          script:
          - define MinionRange '<npc.flag[Minion Awareness Range]>'
          - if <npc.navigator.target_entity||null> == <player> && '<npc.location.find.players.within[%MinionRange%].size||0>' >= 1 {
            - attack <npc> 'target:<npc.location.find.players.within[%MinionRange%].get[1]>' }
            else attack stop

#====================================================================================================================
"NewMoonBoss Self Heal":

# If you typed "Yes" in the  "Boss Self Healing" constant value,
# a exit proximity trigger will check to see if there are any players left in
# proximity.. if not, it will run this task below which will heal the NPC 1
# health every 5 seconds.
#
# If players enter proximity, this task is cancelled and the boss will stop healing.
#
    type: task
    debug: false
    script:
    - define BossRange '<npc.constant[Boss Awareness Range]>'
    - if <npc.health> < <npc.health.max> && '<npc.location.find.players.within[%BossRange%].size||0>' < 1 && !<npc.has_flag[HealActive]> {
      - flag <npc> HealActive
      - heal <npc> 1
      - wait 5
      - flag <npc> HealActive:!
      - run "NewMoonBoss Self Heal" id:<npc.name>_BossHeal }


#====================================================================================================================
"NewMoonBoss Reset":

# This script is used to RESET the boss back to start (health back to 100%, all spawned minions removed, all player damage/counter flags reset, 
# all boss targets, effects and flags cleared and Minecraft scoreboard removed.
#
# This task will only run if the "Boss Reset Timer" constant value is set to 1 or higher and when the last player leaves the boss proximity. When a
# player enters proximity, the "BossResetTimer" flag timer is NULL'ed, so when the task runs it fails on the first IF and boss is not reset.

    type: task
    debug: false
    script:
    - ^if <npc.has_flag[BossResetTimer]> {
      - define SpecialAttackQueue 'Boss<npc.id>SpecialAttack'
      - if <queue.exists[%SpecialAttackQueue%]> queue 'queue:%SpecialAttackQueue%' clear
      - foreach '<npc.flag[Enabled Boss Stages].as_list>' {
        - if <npc.has_flag[Stage%value%Minions]> {
          - foreach <npc.flag[Stage%value%Minions].as_list> {
            - if <npc> != %value% remove %value% 
          }
        }
      }
      - foreach '<npc.flag[Enabled Boss Stages].as_list>' {
        - flag <npc> Stage%value%Minions:! }
       
      - narrate "<red>BOSS EVENT<&co> <white><npc.name><red> has been reset." targets:<npc.flag[BossPlayerList].as_list
      - if <npc.flag[BossHitList].size> >= 1 {
        - foreach <npc.flag[BossHitList].as_list> {
          - flag player:%value% <npc.name>_TotalDamage:!
          - flag player:%value% <npc.name>_HitCount:!
          - flag player:%value% <npc.name>_MinsKilled:!
          - flag player:%value% <npc.name>_MinsHit:!
          - flag player:%value% <npc.name>_MinsDamage:! }
      }
      - execute as_server "npc sel <npc.id>" silent
      - execute as_server "npc effect --play none" silent
      - execute as_server "sentry target clear" silent
      - if <npc.has_flag[Scoreboard]> {
        - if <npc.flag[Scoreboard]> == bosshealth execute as_server "scoreboard objectives remove <npc.name.substring[1,9]>.Damage" silent
          else if <npc.flag[Scoreboard]> == minionkills execute as_server "scoreboard objectives remove <npc.name.substring[1,5]>.MinionKills" silent
          else if <npc.flag[Scoreboard]> == minionhealth execute as_server "scoreboard objectives remove <npc.name.substring[1,6]>.MinionDmg" silent
      }
      - teleport "<npc>" "location:<npc.constant[Boss Spawn Location]>"
      - heal <npc>
      - flag <npc> BossHitList:!
      - flag <npc> BossSpectatorList:!
      - flag <npc> BossStage:!
      - flag <npc> BossPlayerList:!
      # - flag <npc> BadLoopProtect:!  not sure that this flag is being used.
      - flag <npc> ActiveSpecialAttackStage:!
      - flag <npc> MinionSpawnedStage:!
      - flag <npc> Scoreboard:!
      - flag <npc> AllMyMinions:!
      - flag <npc> BossResetTimer:!
      - flag <npc> HealActive:!
    }

"NewMoonBoss Special Attack - Arrows":
#=====================================================================================
  # The following sections contains several scripts that are all used by the "special attack" that is enabled in the constant values "Stage One/Two/Three
  # /Four Special Attack" at the top of the script.
  #
  # When the task is executed, it checks the following criteria:
  # * PreventDoubleAttack: This flag is to prevent the task from running when it's already active. If the flag wasn't there it would've happened when
  #   another player entered the boss's proximity.
  # * Find players within a radius specified in constant "Boss Awareness Range" from the NPC: This prevents the task from running if no one is there.
  # * Boss Stage: This is used to check if the boss is in an attack stage, e.g. the fight isn't over.
  # * Active Special Attack Stage: Checks if the "Arrows" attack is still relevant for the particular boss stage we're in.
  #
  # If all of those are met, it waits 5 seconds and then runs the task again. If the criteria isn't met, it moves onto the "else if" section where it 
  # checks whether the ActiveSpecialAttackStage is null (first time a special attack script is executed) OR whether it's looping for a second time and 
  # "Arrows" is still the relevant special attack. It then does another check to see if there are players within a "Boss Awareness Range" block radius.
  #
  # After that, it flags the NPC with its current active special attack and puts the "PreventDoubleAttack" protection flag in place, with an expiry (just in
  # time for the next intended delayed attack). It then finds a random player within a "Boss Awareness Range" block radius and uses the "shoot" command to
  # shoot the arrow towards their location. Each arrow (entity) that gets fired is recorded into a global flag called "ArrowList". This list is used later in the
  # world script to check who the arrow came from and what "special attack" to apply. e.g. poison, blindness etc.
  #
  # It then waits for the period of time specified in the "Stage One/Two/Three/Four Special Attack Delay", does a quick check to see if there are at least
  # one player in proximity and also if this attack is still relevant, e.g. the boss isn't into the next stage which may be using another special attack.

#====================================================================================================================
  type: task
  debug: false
  script:
    - ^if <npc.has_flag[PreventDoubleAttack]> && <npc.flag[ActiveSpecialAttackStage]||null> == "Arrows" {
      - ^wait 5s
      - ^if <npc.flag[ActiveSpecialAttackStage]||null> == "Arrows" run "NewMoonBoss Special Attack - Arrows" id:Boss<npc.id>SpecialAttack 
    }
      else if <npc.flag[ActiveSpecialAttackStage]||null> == null || <npc.flag[ActiveSpecialAttackStage]||null> == "Arrows" {
        - ^define BossStage <npc.flag[BossStage]||null>
        - ^define BossRange '<npc.constant[Boss Awareness Range]>'
        - ^define NearbyPlayers '<npc.location.find.players.within[%BossRange%].as_list||null>'
        - if <%NearbyPlayers%.size> >= 1 && %BossStage% != null {
          - ^flag <npc> ActiveSpecialAttackStage:Arrows
          - ^flag <npc> PreventDoubleAttack "duration:<npc.constant[Stage %BossStage% Special Attack Delay]>"
          - ^define arrowplayer <%NearbyPlayers%.random>
          - ^narrate "<red><npc.name> shoots a <npc.flag[CurrentSpecialAttack]> towards <yellow><%arrowplayer%.name><red>..." targets:<npc.flag[BossPlayerList].as_list>
          - ^shoot arrow origin:<npc> destination:<%arrowplayer%.location> Height:0.1 save:shot
          - ^foreach <entry[shot].shot_entities> {
            - ^flag global ArrowList:->:%value% }
          - ^wait '<npc.constant[Stage %BossStage% Special Attack Delay]>'
          - ^if <npc.flag[ActiveSpecialAttackStage]||null> == "Arrows" run "NewMoonBoss Special Attack - Arrows" id:Boss<npc.id>SpecialAttack
        }
      }

"NewMoonBoss Special Attack - Rain Arrows":
#-------------------------------------------------------------------------------
# This script uses a "Cuboid" which are the two values you specified in the constant values "Cuboid Spawn Area Poss 1" and "Cuboid Spawn Area 
# Poss 2" at the top of the script.
#
# The cuboid should be a square INSIDE your fighting room. If the cuboid is larger than your room, you'll have arrows spawning outside of the room.
# 
# If you want to see where your cuboid outline is, type the following command in Minecraft, with the NPC selected, and it'll create fake glass 
# blocks that will  disappear in 10 seconds:
#
#     /ex showfake glass <<npc.flag[cuboid]>.get_outline> duration:10s
#-------------------------------------------------------------------------------
    type: task
    debug: true
    script:
    - ^if <npc.has_flag[PreventDoubleAttack]> && <npc.flag[ActiveSpecialAttackStage]> == "Rain Arrows" {
      - ^wait 5s
      - ^if <npc.flag[ActiveSpecialAttackStage]> == "Rain Arrows" run "NewMoonBoss Special Attack - Rain Arrows" id:Boss<npc.id>SpecialAttack 
    }
    # lines above form a loop that runs for the duration of flag[PreventDoubleAttack], lines below will run when the flag clears.
      else if %AttackStage% == null || %AttackStage% == "Rain Arrows" {
        - ^define BossStage <npc.flag[BossStage]||null>
        - ^define BossRange '<npc.constant[Boss Awareness Range]>'
        - ^define NearbyPlayers '<npc.location.find.players.within[%BossRange%].as_list||null>'
        - if <%NearbyPlayers%.size> >= 1 && %BossStage% != null {
          - ^flag <npc> "ActiveSpecialAttackStage:Rain Arrows"
          - ^flag <npc> PreventDoubleAttack "duration:<npc.constant[Stage %BossStage% Special Attack Delay]>"
          - ^narrate "<red><npc.name> causes it to Rain Arrows..." targets:<npc.flag[BossPlayerList].as_list>
          - ^define cuboid <npc.flag[cuboid]>
          - ^define roof <%cuboid%.max.y.add[-1]>
          - ^define minX <%cuboid%.min.x.add[+1].as_int>
          - ^define maxX <%cuboid%.max.x.add[-1].as_int>
          - ^define minZ <%cuboid%.min.z.add[+1].as_int>
          - ^define maxZ <%cuboid%.max.z.add[-1].as_int>
          # The attack will now repeat the number of times specified in the constants. (initial value here 200)
          - ^repeat '<npc.constant[Stage %BossStage% Special Attack Quantity]||200>' {  
            - ^define Xrange <util.random.int[%minX%].to[%maxX%]>
            - ^define Zrange <util.random.int[%minZ%].to[%maxZ%]>
            - ^spawn i@arrow 'origin:%Xrange%,%roof%,%Zrange%,<npc.constant[World Name]>' }
          - ^wait '<npc.constant[Stage %BossStage% Special Attack Delay]>'
          - ^if <npc.flag[ActiveSpecialAttackStage]> == "Rain Arrows" run "NewMoonBoss Special Attack - Rain Arrows" id:Boss<npc.id>SpecialAttack 
        }
      }
      # whole script ends when the special attack flag on the Boss is changed.
#------------------------------------------------------------------------------------------------------------------------
"NewMoonBoss Special Attack - Lightning Bolt":
    type: task
    debug: true
    script:
    - ^if <npc.has_flag[PreventDoubleAttack]> && <npc.flag[ActiveSpecialAttackStage]> == "Lightning Bolt" {
      - wait 5s
      - if <npc.flag[ActiveSpecialAttackStage]> == "Lightning Bolt" run "NewMoonBoss Special Attack - Lightning Bolt" id:Boss<npc.id>SpecialAttack }

      else if <npc.flag[ActiveSpecialAttackStage]> == null || <npc.flag[ActiveSpecialAttackStage]> == "Lightning Bolt" {
        - ^define BossStage <npc.flag[BossStage]||null>
        - ^define BossRange '<npc.constant[Boss Awareness Range]>'
        - ^define NearbyPlayers '<npc.location.find.players.within[%BossRange%].as_list||null>'
        - ^if <%NearbyPlayers%.size> >= 1 && %BossStage% != null {
          - ^flag <npc> "ActiveSpecialAttackStage:Lightning Bolt"
          - ^flag <npc> PreventDoubleAttack "duration:<npc.constant[Stage %BossStage% Special Attack Delay]>"
          - ^define lightningplayer <%NearbyPlayers%.random>
          - ^narrate "<red><npc.name> calls a Lightning Bolt to hit <yellow><%lightningplayer%.name><red>..." targets:<npc.flag[BossPlayerList].as_list>
          - ^strike destination:<%lightningplayer%.location>
          - wait '<npc.constant[Stage %BossStage% Special Attack Delay]>'
          - if <npc.flag[ActiveSpecialAttackStage]> == "Lightning Bolt" run "NewMoonBoss Special Attack - Lightning Bolt" id:Boss<npc.id>SpecialAttack
        }
      }
#------------------------------------------------------------------------------------------------------------------------
"NewMoonBoss Special Attack - Lightning Storm":
    type: task
    debug: true
    script:
    - ^define NearbyPlayers '<npc.location.find.players.within[%BossRange%]>'
    - ^if <npc.has_flag[PreventDoubleAttack]> && <npc.flag[ActiveSpecialAttackStage]> == "Lightning Storm" {
      - wait 5s
      - if <npc.flag[ActiveSpecialAttackStage]> == "Lightning Storm" run "NewMoonBoss Special Attack - Lightning Storm" id:Boss<npc.id>SpecialAttack }

      else if <npc.flag[ActiveSpecialAttackStage]> == null || <npc.flag[ActiveSpecialAttackStage]> == "Lightning Storm" {
        - ^define BossStage <npc.flag[BossStage]>
        - ^define BossRange '<npc.constant[Boss Awareness Range]>'
        - ^define NearbyPlayers '<npc.location.find.players.within[%BossRange%].as_list||null>'
        - ^if <%NearbyPlayers%.size> >= 1 && %BossStage% != null {
          - ^flag <npc> "ActiveSpecialAttackStage:Lightning Storm"
          - ^flag <npc> PreventDoubleAttack "duration:<npc.constant[Stage %BossStage% Special Attack Delay]>"
          - ^narrate "<red><npc.name> calls a Lightning Storm!" targets:<npc.flag[BossPlayerList].as_list>
          - ^define cuboid <npc.flag[cuboid]>
          - ^define floor <%cuboid%.min.y>
          - ^define minX <%cuboid%.min.x.add[+1].as_int>
          - ^define maxX <%cuboid%.max.x.add[-1].as_int>
          - ^define minZ <%cuboid%.min.z.add[+1].as_int>
          - ^define maxZ <%cuboid%.max.z.add[-1].as_int>
          # The attack will now repeat the number of times specified in the constants. (initial value here 20)
          - repeat '<npc.constant[Stage %BossStage% Special Attack Quantity]||20>' { 
            - ^define Xrange <util.random.int[%minX%].to[%maxX%]>
            - ^define Zrange <util.random.int[%minZ%].to[%maxZ%]>
            - strike 'destination:%Xrange%,%floor%,%Zrange%,<npc.constant[World Name]>' }
          - wait '<npc.constant[Stage %BossStage% Special Attack Delay]>'
          - if <npc.flag[ActiveSpecialAttackStage]> == "Lightning Storm" run "NewMoonBoss Special Attack - Lightning Storm" 
        }
      }
#-----------------------------------------------------------------------------------------------------------------------
"NewMoonBoss Special Attack - TNT":
    type: task
    debug: true
    script:
    - ^if <npc.has_flag[PreventDoubleAttack]> && <npc.flag[ActiveSpecialAttackStage]> == "TNT" {
      - wait 5s
      - if <npc.flag[ActiveSpecialAttackStage]> == "TNT" run "NewMoonBoss Special Attack - TNT" id:Boss<npc.id>SpecialAttack }

      else if <npc.flag[ActiveSpecialAttackStage]> == null || <npc.flag[ActiveSpecialAttackStage]> == "TNT" {
        - ^define BossStage <npc.flag[BossStage]>
        - ^define BossRange '<npc.constant[Boss Awareness Range]>'
        - ^define NearbyPlayers '<npc.location.find.players.within[%BossRange%].as_list||null>'
        - ^if <%NearbyPlayers%.size> >= 1 && %BossStage% != null {
          - flag <npc> ActiveSpecialAttackStage:TNT
          - flag <npc> PreventDoubleAttack "duration:<npc.constant[Stage %BossStage% Special Attack Delay]>"
          - define targetplayer "<%NearbyPlayers%.random>"
          - narrate "<red><npc.name> lobs TNT at <yellow><%targetplayer%.name><red>..." targets:<npc.flag[BossPlayerList].as_list>
          - playsound location:<%targetplayer%.location> sound:fuse
          - shoot e@primed_tnt origin:<npc> destination:<%targetplayer%.location.simple> Height:0.5
          - wait <npc.constant[Stage %BossStage% Special Attack Delay]>'
          - if <npc.flag[ActiveSpecialAttackStage]> == "TNT" run "NewMoonBoss Special Attack - TNT" id:Boss<npc.id>SpecialAttack }
      }
#----------------------------------------------------------------------------------------------------------------------------------------
"NewMoonBoss Special Attack - TNT Drop":
    type: task
    debug: true
    script:
    - ^if <npc.has_flag[PreventDoubleAttack]> && <npc.flag[ActiveSpecialAttackStage]> == "TNT Drop" {
      - wait 5s
      - if <npc.flag[ActiveSpecialAttackStage]> == "TNT Drop" run "NewMoonBoss Special Attack - TNT Drop" id:Boss<npc.id>SpecialAttack }

      else if <npc.flag[ActiveSpecialAttackStage]> == null || <npc.flag[ActiveSpecialAttackStage]> == "TNT Drop" {
        - ^define BossStage <npc.flag[BossStage]>
        - ^define BossRange '<npc.constant[Boss Awareness Range]>'
        - ^define NearbyPlayers '<npc.location.find.players.within[%BossRange%].as_list||null>'
        - ^if <%NearbyPlayers%.size> >= 1 && %BossStage% != null {
          - ^flag <npc> "ActiveSpecialAttackStage:TNT Drop"
          - ^flag <npc> PreventDoubleAttack "duration:<npc.constant[Stage %BossStage% Special Attack Delay]>"
          - ^narrate "<red><npc.name> drops primed TNT.. TAKE COVER!" targets:<npc.flag[BossPlayerList].as_list>
          - ^define cuboid <npc.flag[cuboid]>
          - ^define roof <%cuboid%.max.y.add[-1]>
          - ^define minX <%cuboid%.min.x.add[+1].as_int>
          - ^define maxX <%cuboid%.max.x.add[-1].as_int>
          - ^define minZ <%cuboid%.min.z.add[+1].as_int>
          - ^define maxZ <%cuboid%.max.z.add[-1].as_int>
          # The attack will now repeat the number of times specified in the constants. (initial value here 25)
          - ^repeat '<npc.constant[Stage %BossStage% Special Attack Quantity]||25>' {
            - ^define Xrange <util.random.int[%minX%].to[%maxX%]>
            - ^define Zrange <util.random.int[%minZ%].to[%maxZ%]>
            - ^spawn e@primed_tnt 'origin:%Xrange%,%roof%,%Zrange%,<npc.constant[World Name]>' }
        - wait '<npc.constant[Stage %BossStage% Special Attack Delay]>'
        - if && <npc.flag[ActiveSpecialAttackStage]> == "TNT Drop" run "NewMoonBoss Special Attack - TNT Drop" id:Boss<npc.id>SpecialAttack }
      }

#-----------------------------------------------------------------------------------------------------------------------------------
"NewMoonBoss Special Attack - Throw":
    type: task
    debug: true
    script:
    - ^if <npc.has_flag[PreventDoubleAttack]> && <npc.flag[ActiveSpecialAttackStage]> == "Throw" {
      - wait 5s
      - if <npc.flag[ActiveSpecialAttackStage]> == "Throw" run "NewMoonBoss Special Attack - Throw" id:Boss<npc.id>SpecialAttack }
      
      else if <npc.flag[ActiveSpecialAttackStage]> == null || <npc.flag[ActiveSpecialAttackStage]> == "Throw" {
        - ^define BossStage <npc.flag[BossStage]>
        - ^define BossRange '<npc.constant[Boss Awareness Range]>'
        - ^define NearbyPlayers '<npc.location.find.players.within[%BossRange%].as_list||null>'
        - ^if <%NearbyPlayers%.size> >= 1 && %BossStage% != null {
          - ^flag <npc> PreventDoubleAttack "duration:<npc.constant[Stage %BossStage% Special Attack Delay]>"
          - ^flag <npc> ActiveSpecialAttackStage:Throw
          # The next line defines how many players will be thrown, from the value entered in the constants (initial value here 3)
          - ^define NumberOfPlayers '<npc.constant[Stage %BossStage% Special Attack Quantity]||1>'
          - ^flag <npc> "ThrowList:|:<%NearbyPlayers%.random[%NumberOfPlayers%]>"
          - ^narrate "<red><npc.name> throws <npc.flag[Throwlist].formatted>..." targets:<npc.flag[BossPlayerList].as_list>
          - ^define cuboid <npc.flag[cuboid]>
          - ^define roof <%cuboid%.max.y.add[-1]>
          - ^define minX <%cuboid%.min.x.as_int>
          - ^define maxX <%cuboid%.max.x.as_int>
          - ^define minZ <%cuboid%.min.z.as_int>
          - ^define maxZ <%cuboid%.max.z.as_int>
          - ^foreach <npc.flag[Throwlist].as_list> {
            - ^flag <npc> ThrowList:<-:%value%
            - ^define Xrange <util.random.int[%minX%].to[%maxX%]>
            - ^define Zrange <util.random.int[%minZ%].to[%maxZ%]>
            - ^shoot %value% origin:<%value%.location.simple> 'destination:%Xrange%,%roof%,%Zrange%,<npc.constant[World Name]>' height:1.8 gravity:0.32 }
          - ^flag <npc> ThrowList:!
          - wait '<npc.constant[Stage %BossStage% Special Attack Delay]>'
          - if <npc.flag[ActiveSpecialAttackStage]> == "Throw" run "NewMoonBoss Special Attack - Throw" id:Boss<npc.id>SpecialAttack 
        }
      }
#-------------------------------------------------------------------------------------------------------------------------------
"NewMoonBoss Special Attack - Firestarter":
    type: task
    debug: false
    script:
    - ^if <npc.has_flag[PreventDoubleAttack]> && <npc.flag[ActiveSpecialAttackStage]> == "Firestarter" {
      - wait 5s
      - if <npc.flag[ActiveSpecialAttackStage]> == Firestarter run "NewMoonBoss Special Attack - Firestarter" id:Boss<npc.id>SpecialAttack }

      else if <npc.flag[ActiveSpecialAttackStage]> == null || <npc.flag[ActiveSpecialAttackStage]> == Firestarter {
        - ^define BossStage <npc.flag[BossStage]>
        - ^define BossRange '<npc.constant[Boss Awareness Range]>'
        - ^define NearbyPlayers '<npc.location.find.players.within[%BossRange%].as_list||null>'
        - ^if <%NearbyPlayers%.size> >= 1 && %BossStage% != null {
          - ^flag <npc> PreventDoubleAttack 'duration:<npc.constant[Stage %BossStage% Special Attack Delay]>'
          - ^flag <npc> ActiveSpecialAttackStage:Firestarter
          - ^narrate "<red><npc.name> sets the place on fire..." targets:<npc.flag[BossPlayerList].as_list>
          - ^define cuboid <npc.flag[cuboid]>
          # ^The attack will now the number of fires specified in the constants. (initial value here 20)
          - ^repeat '<npc.constant[Stage %BossStage% Special Attack Quantity]||20>' {
            - ^modifyblock location:<%cuboid%.get_spawnable_blocks.random> fire }
          - wait '<npc.constant[Stage %BossStage% Special Attack Delay]>'
          - if <npc.flag[ActiveSpecialAttackStage]> == "Firestarter" run "NewMoonBoss Special Attack - Firestarter" id:Boss<npc.id>SpecialAttack 
        }
      }
      
"NewMoonBoss Special Attack Handler":
#-------------------------------------------------------------------------------#
# This section is primarily to handle the different types of arrows the boss
# can shoot as part of it's special attacks. It determines which spell to "cast"
# based on what the current active special attack is.
#
# It'll also narrate a random message to the boss player list about who got hit
# and what the effect is.
#
# The other purpose here is to show the "blood" effect when you hit the NPC. It
# uses the the "drip_lava" effect but draws 300 of them to make it look like a
# bloody mist. Thanks to blankiito for this effect!
#-------------------------------------------------------------------------------#
  type: world
  debug: false
  events:
    on npc damaged by player:
    - if <context.entity> contains <global.flag[ListOfBosses].as_list> && !<context.entity.has_flag[NoBlood]> {
      - playeffect location:<context.entity.location> effect:DRIP_LAVA radius:10 qty:300 offset:0.15 }

    on player damaged by arrow:
    - ^if <context.projectile> !contains <global.flag[ArrowList].as_list> queue clear
    - ^if <context.damager> !contains <global.flag[ListOfBosses].as_list> queue clear
    - define target <context.entity.name>
    - define hearers <context.damager.flag[BossPlayerList].as_list>
    - flag global ArrowList:<-:<context.projectile>
    - if <context.damager.flag[CurrentSpecialAttack]> == "Poison Arrow" {
      - cast poison duration:3 power:1 <context.entity>
      - random {
        - narrate "<red>...and hits <yellow>%target%<red>, causing them to bleed from the ears." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing agonising pain and loss of health." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing itchy and burning skin blisters." targets:%hearers% }
      }
      else if <context.damager.flag[CurrentSpecialAttack]> == "Wither Arrow" {
      - cast wither duration:3 power:1 <context.entity>
      - random {
        - narrate "<red>...and hits <yellow>%target%<red>, causing their skin to peel off." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing their limbs to decay." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing their skin to ooze." targets:%hearers% }
      }
      else if <context.damager.flag[CurrentSpecialAttack]> == "Weakness Arrow" {
      - cast weakness duration:3 power:1 <context.entity>
      - random {
        - narrate "<red>...and hits <yellow>%target%<red>, causing them to become weak and tired." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing them to deal less damage." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing them to hit like a little girl." targets:%hearers% }
      }
      else if <context.damager.flag[CurrentSpecialAttack]> == "Slowness Arrow" {
      - cast slow duration:10 power:3 <context.entity>
      - random {
        - narrate "<red>...and hits <yellow>%target%<red>, causing them to become slow and lazy." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing them to walk at a snails pace." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing them to be slower than a speeding microorganism." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing them to be slower than a 1 legged dog on tranquilizers." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing them to be slower than a geriatric slug on a salted snowed-in street." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing them to be slower than a snail traveling through peanut butter." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing them to be slower than Java." targets:%hearers%
        - narrate "<red>...and hits <yellow>%target%<red>, causing them to be slower than quadriplegic in a sack race." targets:%hearers% }
      }
      
"NewMoonBoss Drop the Loot":
#-------------------------------------------------------------------------------#
# Loot can be delivered in 3 different ways. 
# 1) In the player inventory, using the "give" command.
# 2) Drop around where the boss died.
# 3) Inside a chest that spawns in close proximity to where the boss died.
#
# How does it decide the loot? By using a procedure script of course! This
# type of script returns us a single value. Further explained in the next
# section.
#-------------------------------------------------------------------------------#
    type: task
    debug: false
    script:
    - if '<npc.constant[Loot Distribution]>' == player {
      - foreach <npc.flag[BossHitList].as_list> {
        - repeat '<npc.constant[Loot Quantity]>' {
          - give to:<%value%.inventory> 'i@<proc:Bossfight Determine Loot>' }
      }
      - queue clear }
      
    - if '<npc.constant[Loot Distribution]>' == boss {
      - foreach <npc.flag[BossHitList].as_list> {
        - repeat '<npc.constant[Loot Quantity]>' {
          - drop 'i@<proc:Bossfight Determine Loot>' location:<npc.flag[DeathLocation]> }
        }
      - queue clear }
      
    - if '<npc.constant[Loot Distribution]>' == chest {
      - define location <npc.location.simple>
      - define cuboid <el@val[<l@%location%.add[l@-2,0,-2]>|<l@%location%.add[l@2,1,2]>].as_cuboid>
      - define chestlocation <%cuboid%.get_spawnable_blocks.random.block.as_location.block>
      - flag <npc> LootChestLocationList:->:%chestlocation% 
      - define signlocation <%chestlocation%.add[l@0,1,0]>
      - modifyblock location:%chestlocation% chest
      - sign %signlocation% "Loot Chest|for|all warriors|to share"
      - foreach <npc.flag[BossHitList].as_list> {
        - repeat '<npc.constant[Loot Quantity]>' {
          - give "i@<proc:Bossfight Determine Loot>" to:<%chestlocation%.inventory> }
      }
    }  
      else if '<npc.constant[Loot Distribution]>' == playerchest {
        - flag <npc> PlayersGettingChest:<npc.flag[BossHitList]>
        - foreach <npc.flag[BossHitList].as_list> {
          - define location <%value%.location.simple>
          - define cuboid <el@val[<l@%location%.add[l@-2,0,-2]>|<l@%location%.add[l@2,1,2]>].as_cuboid>
          - define chestlocation <%cuboid%.get_spawnable_blocks.random.as_location.block>
          - define signlocation <%chestlocation%.add[l@0,1,0]>
          - flag %value% LootChestLocation:%chestlocation%
          - flag <npc> LootChestLocationList:->:%chestlocation%
          - flag global LootChestList:->:%chestlocation%
          - modifyblock location:%chestlocation% chest
          - sign %signlocation% "Loot Chest|for|<%value%.name.display>"
          - repeat '<npc.constant[Loot Quantity]>' {
            - give 'i@<proc:Bossfight Determine Loot>' to:<%chestlocation%.inventory> }
        }        
      }
    - if <npc.flag[LootChestLocationList].size||0> >= 1 && "<npc.constant[Loot Chest Expiry]>" >= 1 run "NewMoonBoss Loot Chest Expiry" "delay:<npc.constant[Loot Chest Expiry]>"

"NewMoonBoss Loot Chest Expiry":
#-------------------------------------------------------------------------------#
# This task will run with a delay specified in the "Loot Chest Expiry" constant
# value at the top of the script.
#
# It simply removes the chests and drop the items on the floor.
#-------------------------------------------------------------------------------#
    type: task
    debug: false
    script:
    - ^foreach <npc.flag[LootChestLocationList].as_list||li@> {
      - if <location[%value%].block.material||null> == m@chest {
        - flag global LootChestList:<-:%value%
        - modifyblock <%value%.add[l@0,1,0]> air 
        - modifyblock %value% air 
      }
    }
    - ^foreach <npc.flag[PlayersGettingChest].as_list||li@> {
      - flag %value% LootChestLocation:! }
    - ^flag <npc> PlayersGettingChest:!
    - ^flag <npc> LootChestLocationList:!

# <snip> 
# Loot items and associated scripts are now in a separate .yml file.
